# G0-面试题

# 八股文

## 垃圾回收

垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。

### 常见的垃圾回收算法

- 引用计数：每个对象维护一个引用计数，当对象创建或被赋值给其它对象时引用计数自动加1；销毁则减1。计数为0进行回收。
    - 优点：对象回收快，不会出现内存耗尽或到阀值才回收。
    - 缺点：不能很好的处理循环引用。
- 标记-清楚：从跟变量开始遍历所有应用的对象，引用的对象标记“被应用”，没有标记的就被回收。
    - 优点：解决了引用技术的缺点。
    - 缺点：需要STW(stop the world)，需要停止程序运行。
- 分代收集：按照对象生命周期长短划分不同的代空间[什么意思？]，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
    - 优点：回收性能好。
    - 缺点：算法复杂。

### 三色标记法

- 初始状态下所有的对象都是白色的。
- 从根节点开始遍历所有对象，把遍历到的对象标记成灰色对象。
- 遍历灰色对象，将灰色对象引用的对象也标记成灰色对象，将已遍历过的灰色对象标记呈黑色对象。
- 循环第三步，直到所有的灰色对象都变成黑色对象。
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作[这个不一定对]。
- 回收白色对象。

![Untitled](G0-%E9%9D%A2%E8%AF%95%E9%A2%98%2063e68ab17b3e42fba9147475f6348233/Untitled.png)

### STW(stop the world)

- 为了防止在GC标记过程中，对象之间的引用关系发生新的变更导致标记错，故停止程序的运行。
- STW对性能有一些影响，Go目前已经可以做到1ms一下的STW。

### 写屏障(write Barrier)

- 为了防止在GC标记过程中，对象之间的引用关系发生新的变更导致标记错，我们需要进行STW，但是STW会暂停程序的运行导致服务不可用。所以引入了写屏障技术来减少暂停时间。
- 造成引用对象被回收的条件：
    
    一个黑色对象A新增了指向白色对象C的引用，并且白色对象C没有被除A对象以外的其它灰色节点的引用，或者存在之前的引用对象已被GC回收。即一下条件：
    
    - 对象A已扫描完毕，A指向C的引用无法再被扫描到；
    - 对象C无其它灰色对象引用，扫描结束就回被当做回收对象
    
    解决方式：
    
    - 破坏条件1：Dijistra 写屏障
        
        满足强三色不变性：黑色对象不允许引用白色对象，当有白色对象引用时将白色对象标记为灰色。
        
    - 破坏条件2：Yuasa 写屏障
        
        满足弱三色不变行：黑色对象允许引用白色对象，但是此白色对象已被灰色对象引用，如果这个灰色对象对白色对象的引用删除，就认为白色对象已被黑色对象引用，需要标记为灰色。
        
        ![Untitled](G0-%E9%9D%A2%E8%AF%95%E9%A2%98%2063e68ab17b3e42fba9147475f6348233/Untitled%201.png)
        

## GPM调度和CSP模型

### CSP 模型

      CSP(Communication Sequential Process) 通信顺序进程，CSP模型是”以通讯的方式来共享内存“，不同于传统的多线程通过共享内存来通讯。用于描述两个独立的并发实体通过共享的通讯channel(管道)进行通信的并发模型。[具体的CSP概念请百度，这个知识在golang中可以这么说]

### GMP 含义

- G(Goroutine): 协程，用户态的线程。以函数执行
- M(Machine): 线程，CPU最小的调用单位，传统意义中的线程。
- P(Processor): 处理器(GO中定义的一个概念，非CPU), 真正运行的线程数，并行数。通过GOMAXPROCS()来设置，默认为CPU核心数。

**注意：M必须绑定到P上面才可以运行协程G。P含有一个包含多个G的队列，P调用G交由M进行执行。**

**注意:  G的阻塞一般为channel或者network I/O, 此时的阻塞不会影响M的运行，M会寻找下一个G进行执行。当遇到系统调用等阻塞时，会释放P。P会绑定其它可用的M继续执行。**

### Goroutine 调度策略

- 队列分为两种：
    - P的局部队列
    - 全局队列
- 调度对象有三种,对应着GMP描述
- 调度流程：
    - P先绑定到M,让M执行P局部队列中的G(**注意：**这里有1/61的概率会取全局队列中的G，以防止全局队列中的G饿死),按顺序逐个执行。
    - 新来的G会优先加入产生自己P的局部队列，如果局部队列满了，会添加到全局队列中
    - 当P的局部队列为空时，P绑定的M会从全局队列中获取一半G到本地队列中
    - 当全局队列也为空时，会从Netpoll和事件池中获取
    - 当Netpoll和事件池中为空时，就会窃取其它P的局部队列中的一半G到本地队列中
    - 当其它P的局部队列中也没有G可执行时，这时的P和M会有什么操作？ 睡眠？还是阻塞？还是自旋？
        - 答案线程会先自旋，如果自旋线程数过多的时候会暂停
    
    ![Untitled](G0-%E9%9D%A2%E8%AF%95%E9%A2%98%2063e68ab17b3e42fba9147475f6348233/Untitled%202.png)
    

## chan 原理

### 结构体(类描述)

```go
// 文件路径：runtime/chan.go 
// channel类描述
type hchan struct {
	qcount   uint           // total data in the queue 队列中的总元素个数
	dataqsiz uint           // size of the circular queue 队列空间(环形存储)
	buf      unsafe.Pointer // points to an array of dataqsiz elements 队列地址
	elemsize uint16 // 每个元素的大小
	closed   uint32 // 关闭标识
	elemtype *_type // element type   每个元素的类型
	sendx    uint   // send index  发送索引
	recvx    uint   // receive index  接收索引 
	recvq    waitq  // list of recv waiters 等待接收消息的协程队列
	sendq    waitq  // list of send waiters 等待写消息的协程队列

	// lock protects all fields in hchan, as well as several
	// fields in sudogs blocked on this channel.
	//
	// Do not change another G's status while holding this lock
	// (in particular, do not ready a G), as this can deadlock
	// with stack shrinking.

	// 锁保护hchan中的所有字段，以及几个
	// sudogs 中的字段在此通道上被阻止。
	//
	// 持有这个锁时不要改变另一个 G 的状态
	//（特别是不要准备一个G），因为这会死锁
	// 堆栈收缩。
	lock mutex // 控制并发的
}

// 协程队列类描述
type waitq struct {
	first *sudog
	last  *sudog
}

// 文件路径：runtime/runtime2.go
// sudog 代表等待列表中的一个g，例如用于在channel上发送/接收。.
type sudog struct {
	// The following fields are protected by the hchan.lock of the
	// channel this sudog is blocking on. shrinkstack depends on
	// this for sudogs involved in channel ops.
	// 以下字段受此 sudog 阻塞的通道的 hchan.lock 保护。 对于参与通道操作的 sudog，收缩堆栈取决于此。

	g *g                // 协程

 	next *sudog         // 下一个协程
	prev *sudog         // 上一个协程 (双向链表)
	elem unsafe.Pointer // data element (may point to stack) 数据元素(有可能是堆上的地址)

	// The following fields are never accessed concurrently.
	// For channels, waitlink is only accessed by g.
	// For semaphores, all fields (including the ones above)
	// are only accessed when holding a semaRoot lock.

	// 以下字段永远不会同时访问。 对于通道，waitlink 只能被 g 访问。对于信号量，所有字段（包括上面的那些）只有在持有 semaRoot 锁时才被访问。

	acquiretime int64   // 获取时间
	releasetime int64   // 释放时间
	ticket      uint32  // 票

	// isSelect indicates g is participating in a select, so
	// g.selectDone must be CAS'd to win the wake-up race.

	// is Select 表示 g 正在参与选择，因此 g.selectDone 必须经过 CAS 处理才能赢得唤醒竞赛。
	isSelect bool       // 参与选择标识

	// success indicates whether communication over channel c
	// succeeded. It is true if the goroutine was awoken because a
	// value was delivered over channel c, and false if awoken
	// because c was closed.

  // success 表示通过通道 c 的通信是否成功。 如果 goroutine 因为通过通道 c 传递了一个值而被唤醒，则为 true，如果因为 c 已关闭而唤醒，则为 false。
	success bool  // c channel 通信成功标识

	parent   *sudog // semaRoot binary tree // semaRoot 二叉树 (目前不知道是做什么的，等以后再详细看)
	waitlink *sudog // g.waiting list or semaRoot 
	waittail *sudog // semaRoot
	c        *hchan // channel
}

```

### 读写流程

- 向channel写数据：
    - 1.若等待接收队列recvq不为空，则缓存冲区中无数据或无缓存区，将直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程。
    - 2.若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。
    - 3.若缓冲区中没有空余位置，则将发送数据写入G,将当前G加入sendq,进入睡眠，等待被读goroutine唤醒。
- 从channel读数据：
    - 1.若等待发送队列sendq不为空，且没有缓冲区，直接从sendq中读取G,把G中数据读出，最后把G唤醒，结束读取过程。
    - 2.如果等待发送队列sendq不为空，说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程。
    - 3.如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。
    - 4.将当前goroutine加入recvq,进入睡眠，等待被写goroutine唤醒。
    
    ![Untitled](G0-%E9%9D%A2%E8%AF%95%E9%A2%98%2063e68ab17b3e42fba9147475f6348233/Untitled%203.png)
    
- 关闭 channel
    - 1.关闭channel 时会将recvq中的G全部唤醒，本该写入G的数据位置为nil.将sendq中的G全部唤醒，但是这些G会panic。
        
        panic出现的场景还有：
        
        - 关闭值为nil的channel
        - 关闭已经关闭的channel
        - 向已经关闭的channel中写数据

### 无缓冲chan 的发送和接收是否同步？

```go
ch := make(chan int) // 无缓冲的channel
ch := make(chan int, 2) // 缓存为2的channel
```

channel无缓存时，发送阻塞直到数据被接收，接收阻塞直到读到数据；

channel有缓存时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。

## context 上下文 结构原理

### 用途

context(上下文)是golang应用开发常用的并发控制技术，它可以控制一组程树状结构的goroutine，每个goroutine拥有相同的上下文，context是并发安全的，主要用于控制多个协程之间的协作、取消操作。

![Untitled](G0-%E9%9D%A2%E8%AF%95%E9%A2%98%2063e68ab17b3e42fba9147475f6348233/Untitled%204.png)

### 数据结构

Context 只定义了接口，凡是实现该接口的类都可称为是一种context。

```go
// 代码位置： src/context/context.go

type Context interface {
   Deadline() (deadline time.Time, ok bool)
   Done() <-chan struct{}
   Err() error
   Value(key interface{}) interface{}
}
```

- Deadline() 方法：可以获取设置的截止时间，返回值deadline是截止时间，到了这个时间，Context会自动发起取消请求，返回值ok表示是否设置了截止时间。
- Done() 方法：返回一个只读的channel，类型为struct{}。如果这个chan可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。
- Err() 方法：返回Context被取消的原因。
- Value() 方法：获取Context上绑定的值，是一个键值对，通过Key来获取对应的值。